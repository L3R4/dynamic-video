typename Uuid = String;
typename Desc = String;
typename Candidates = String;
typename OfferOrAnswer = String;
typename MessageType = [| ConnectionRequest | SDP | Ice |];
typename PCMessage = (uuid : Uuid, dest : String, type : MessageType, sdp : String,
                      sdptype : OfferOrAnswer, iceCandidates : Candidates);

module JSWebRTC {
    alien javascript "js/jsWebRTC.js" {
        checkIfWebcamLoaded : () ~> Bool;
        getWebcamReady : () ~> ();
        setLocalUuid : () ~> ();
        getLocalUuid : () ~> Uuid;
        setUpPC : (Uuid) ~> ();
        addStreamToPC : (Uuid) ~> ();
        connectionInitiatedWithPeer : (Uuid) ~> Bool;
        setLocalDescForPC : (Uuid, OfferOrAnswer) ~> ();
        checkIfLocalDescSetForPC : (Uuid) ~> Bool;
        getLocalDescForPC : (Uuid) ~> Desc;
        setRemoteDescForPC : (Uuid, Desc) ~> ();
        checkIfRemoteDescSetForPC : (Uuid) ~> Bool;
        checkIfConnectedToPeer : (Uuid) ~> Bool;
        disconnectFromUser : (Uuid) ~> ();
        collectCandidates : () ~> (Candidates);
        addCandidates : (Candidates, Uuid) ~> ();
    }
}

fun broadcast(clients, msg) server {
  switch (clients) {
    case [] -> ()
    case c::clients ->
      c ! msg;
      broadcast(clients, msg)
  }
}

fun serverLoop(clients) server {
  receive {
    case Register(pid) ->
      var newClients = pid :: clients;
      serverLoop(newClients)

    case Broadcast(msg) ->
      broadcast(clients, Message(msg));
      serverLoop(clients)
  }
}

var serverPid = spawn { serverLoop([]) };

fun broadcastMessageToPeers(message) {
  serverPid ! Broadcast(message);
  ()
}

fun handleIceCandidates() {
  sleep(500);
  var candidates = JSWebRTC.collectCandidates();
  if (candidates <> "No candidates") {
    var localUuid = JSWebRTC.getLocalUuid();
    var message = (uuid=localUuid, dest="all", type=Ice, sdp="_", sdptype="_", iceCandidates=candidates);
    broadcastMessageToPeers(message);
    handleIceCandidates()
  } else {
    handleIceCandidates()
  }
}

fun waitUntilLocalDescSetForPC(peerUuid) {
  var bool = JSWebRTC.checkIfLocalDescSetForPC(peerUuid);
  if (bool)
    ()
  else
    waitUntilLocalDescSetForPC(peerUuid)
}

fun waitUntilRemoteDescSetForPC(peerUuid) {
  var bool = JSWebRTC.checkIfRemoteDescSetForPC(peerUuid);
  if (bool)
    ()
  else
    waitUntilRemoteDescSetForPC(peerUuid)
}

fun sendDescriptionForPC(peerUuid, sdpType) {
  var desc = JSWebRTC.getLocalDescForPC(peerUuid);
  var localUuid = JSWebRTC.getLocalUuid();
  var message = (uuid=localUuid, dest=peerUuid, type=SDP, sdp=desc, sdptype=sdpType, iceCandidates="_");
  broadcastMessageToPeers(message)
}

fun prepareDescriptionForPC(peerUuid, sdpType) {
  JSWebRTC.setLocalDescForPC(peerUuid, sdpType);
  waitUntilLocalDescSetForPC(peerUuid)
}

fun setUpNewPeer(peerUuid, initCall) {
  JSWebRTC.setUpPC(peerUuid);
  if (initCall) {
    prepareDescriptionForPC(peerUuid, "offer");
    sendDescriptionForPC(peerUuid, "offer")
  } else {
    ()
  }
}

fun handleOfferForPC(peerUuid, remoteDesc) {
  JSWebRTC.setRemoteDescForPC(peerUuid, remoteDesc);
  waitUntilRemoteDescSetForPC(peerUuid);
  prepareDescriptionForPC(peerUuid, "answer");
  sendDescriptionForPC(peerUuid, "answer")
}

fun handleMessage(msg) {
  var localUuid = JSWebRTC.getLocalUuid();
  var peerUuid = msg.uuid;
  if (peerUuid == localUuid || (msg.dest <> localUuid && msg.dest <> "all")) {
    ()
  } else {
    switch (msg.type) {
      case ConnectionRequest ->
        if (not(JSWebRTC.connectionInitiatedWithPeer(peerUuid))) {
          setUpNewPeer(peerUuid, true);
          var iceId2 = spawnClient { handleIceCandidates() };
          ()
        } else {
          ()
        }
      case SDP ->
        if (msg.sdptype == "offer") {
          handleOfferForPC(peerUuid, msg.sdp)
        } else {
          JSWebRTC.setRemoteDescForPC(peerUuid, msg.sdp);
          waitUntilRemoteDescSetForPC(peerUuid)
        }
      case Ice ->
        JSWebRTC.addCandidates(msg.iceCandidates, peerUuid)
    }
  }
}

fun waitForWebcam() {
  var bool = JSWebRTC.checkIfWebcamLoaded();
  if (bool)
    ()
  else
    waitForWebcam()
}

fun readyLocalWebcam() {
  JSWebRTC.getWebcamReady();
  waitForWebcam()
}

# Loop thread run on the client, listens for messages from the server
fun clientLoop() {
  receive {
    case Message(msg) ->
      handleMessage(msg);
      clientLoop()
  }
}

fun clientRegister() {
  JSWebRTC.setLocalUuid();
  readyLocalWebcam();
  serverPid ! Register(self());
  clientLoop()
}

fun connectToUser(peerUuid) {
  if (not(JSWebRTC.connectionInitiatedWithPeer(peerUuid))) {
    setUpNewPeer(peerUuid, false);
    var iceId = spawnClient { handleIceCandidates() };
    var localUuid = JSWebRTC.getLocalUuid();
    var message = (uuid=localUuid, dest=peerUuid, type=ConnectionRequest, sdp="_", sdptype="_", iceCandidates="_");
    broadcastMessageToPeers(message)
  } else {
    ()
  }
}

fun disconnectFromUser(peerUuid) {
  JSWebRTC.disconnectFromUser(peerUuid)
}

fun checkIfConnectedToPeer(peerUuid) {
  JSWebRTC.checkIfConnectedToPeer(peerUuid)
}

fun getUUID() {
  JSWebRTC.getLocalUuid()
}

fun registerUser() {
  var clientPid = spawnClient { clientRegister() };
  ()
}

fun main() {
    addStaticRoute("/js", "js", [("js", "text/javascript")]);
    # Starts the server and distribution
    serveWebsockets()
}

main()
