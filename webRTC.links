module JSWebRTC {
    alien javascript "js/jsWebRTC.js" {
        webcamLoaded : () ~> (String);
        readyWebcam : () ~> ();
        setLocalUuid : () ~> ();
        getLocalUuid : () ~> (String);
        setUpPeer : (String) ~> ();
        addStreamToConnectionWithPeer : (String) ~> ();
        connectionInitiated : (String) ~> (String);
        makeOffer : (String) ~> ();
        makeAnswer : (String) ~> ();
        offerCompleted : (String) ~> (String);
        receivedDescription : (String, String) ~> ();
        remoteDescriptionSet : (String) ~> (String);
        disconnectFromUser : (String) ~> ();
        collectCandidates : () ~> (String);
        addCandidates : (String, String) ~> ();
    }
}

typename MessageType = [| ConnectionRequest | SDP | Ice |];
typename SDPType = [| Offer | Answer | None |];
typename PCMessage = (uuid : String, dest : String, type : MessageType, sdp : String,
                      sdptype : SDPType, iceCandidates : String);

fun broadcast(clients, msg) server {
    switch (clients) {
        case [] -> ()
        case c::clients ->
            c ! msg;
            broadcast(clients, msg)
    }
}

# Loops, keeping track of the client PIDs
fun serverLoop(clients) server {
    receive {
        case Register(pid) ->
            var newClients = pid :: clients;
            serverLoop(newClients)

        case Broadcast(msg) ->
            broadcast(clients, Message(msg));
            serverLoop(clients)
    }
}

var serverPid = spawn { serverLoop([]) };

fun checkForIceCandidates() {
  sleep(500);
  var candidates = JSWebRTC.collectCandidates();
  if (candidates <> "No candidates") {
    var localUuid = JSWebRTC.getLocalUuid();
    var message = (uuid=localUuid, dest="all", type=Ice, sdp="_", sdptype=None, iceCandidates=candidates);
    serverPid ! Broadcast(message);
    checkForIceCandidates()
  } else {
    checkForIceCandidates()
  }
}

fun waitForOffer(peerUuid, sdpType) {
  var result = JSWebRTC.offerCompleted(peerUuid);
  if (result <> "Not finished") {
    var localUuid = JSWebRTC.getLocalUuid();
    var message = (uuid=localUuid, dest=peerUuid, type=SDP, sdp=result, sdptype=sdpType, iceCandidates="_");
    serverPid ! Broadcast(message);
    ()
  } else {
    waitForOffer(peerUuid, sdpType)
  }
}

fun waitForRemoteDescSet(peerUuid) {
  var result = JSWebRTC.remoteDescriptionSet(peerUuid);
  if (result == "Finished")
    ()
  else
    waitForRemoteDescSet(peerUuid)
}

fun setUpNewPeer(peerUuid, initCall) {
  JSWebRTC.setUpPeer(peerUuid);
  if (initCall == true) {
    JSWebRTC.makeOffer(peerUuid);
    waitForOffer(peerUuid, Offer);
    ()
  } else {
    ()
  }
}

fun receivedOffer(peerUuid, desc) {
  JSWebRTC.receivedDescription(peerUuid, desc);
  waitForRemoteDescSet(peerUuid);
  var localUuid = JSWebRTC.getLocalUuid();
  JSWebRTC.makeAnswer(peerUuid);
  waitForOffer(peerUuid, Answer)
}

fun dealWithMessage(msg) {
  var localUuid = JSWebRTC.getLocalUuid();
  var peerUuid = msg.uuid;
  if (peerUuid == localUuid || (msg.dest <> localUuid && msg.dest <> "all")) {
    ()
  } else {
    switch (msg.type) {
      case ConnectionRequest ->
        if (JSWebRTC.connectionInitiated(peerUuid) == "false") {
          setUpNewPeer(peerUuid, true);
          var iceId = spawnClient { checkForIceCandidates() };
          ()
        } else {
          ()
        }
      case SDP ->
        switch (msg.sdptype) {
          case Offer ->
            receivedOffer(peerUuid, msg.sdp)
          case Answer ->
            JSWebRTC.receivedDescription(peerUuid, msg.sdp);
            waitForRemoteDescSet(peerUuid)
          case None ->
            ()
        }
      case Ice ->
        JSWebRTC.addCandidates(msg.iceCandidates, peerUuid)
    }
  }
}

fun shareStreamWithPeer(peerUuid) {
  JSWebRTC.addStreamToConnectionWithPeer(peerUuid)
}

fun waitForWebcam() {
  var result = JSWebRTC.webcamLoaded();
  if (result == "true")
    ()
  else
    waitForWebcam()
}

fun readyLocalWebcam() {
  JSWebRTC.readyWebcam();
  waitForWebcam()
}

# Loop thread run on the client, listens for messages from the server
fun clientLoop() {
    receive {
        case Message(msg) ->
            dealWithMessage(msg);
            clientLoop()
    }
}

fun clientRegister() {
  JSWebRTC.setLocalUuid();
  readyLocalWebcam();
  serverPid ! Register(self());
  clientLoop()
}

fun connectToUser(peerUuid) {
  if (JSWebRTC.connectionInitiated(peerUuid) == "false") {
    setUpNewPeer(peerUuid, false);
    var iceId = spawnClient { checkForIceCandidates() };
    var localUuid = JSWebRTC.getLocalUuid();
    var message = (uuid=localUuid, dest=peerUuid, type=ConnectionRequest, sdp="_", sdptype=None, iceCandidates="_");
    serverPid ! Broadcast(message);
    ()
  } else {
    ()
  }
}

fun disconnectFromUser(peerUuid) {
  JSWebRTC.disconnectFromUser(peerUuid)
}

fun getUUID() {
  JSWebRTC.getLocalUuid()
}

fun registerUser() {
  var clientPid = spawnClient { clientRegister() };
  ()
}

fun main() {
    addStaticRoute("/js", "js", [("js", "text/javascript")]);
    # Starts the server and distribution
    serveWebsockets()
}

main()
