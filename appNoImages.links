open import MvuHTML;
open import MvuAttrs;
open import MvuEvents;
open import MvuSubscriptions;
import Mvu;
import MvuCommands;
import WebRTC;

module JSApp {
  alien javascript "js/app.js" {
    displayLiveStream : (String) ~> ();
    moveLocalVideo : () ~> ();
    removePeerVideoDiv : (String) ~> ();
    takePicture : () ~> ();
    getPictureURL : () ~> String;
    displayIcon : (String, String, String, String) ~> ();
    addPeerToList : (String) ~> ();
  }
}

#broacasts message to all clients on server
fun broadcast(clients, msg) server {
    switch (clients) {
        case [] -> ()
        case c::clients ->
            c ! msg;
            broadcast(clients, msg)
    }
}

#waits for message, sends message to call clients on server
fun serverLoop(clients) server {
    receive {
        case Register(pid) ->
          var newClients = pid :: clients;
          serverLoop(newClients)
        case BcastModelMsg(msg) ->
          broadcast(clients, ModelMessage(msg));
          serverLoop(clients)
    }
}

var serverPid = spawn { serverLoop([]) };

#different ways the character can move
typename CharacterState = [| Up | Down | Left | Right | Still |];

#datetype for character
typename CharacterData =
  (id: String, name: String, x : Float, y: Float, vx : Float, vy : Float,
  directionV : CharacterState, directionH : CharacterState, imageURL : String);

typename ServerMessage = CharacterData;

#messages that the updt function receives
typename Msg =
  [| NewFrame
   | MoveCharV : CharacterState
   | MoveCharH : CharacterState
   | UpdateNameField : String
   | NameEntered
   | Joined
   | NoOp
   | ServerMsg:ServerMessage
  |];

typename RequestMsg =
  [| ModelMessage:ServerMessage | RetrieveMsg:Process({hear:ServerMessage}) |];

#this is the model for MVU
typename Room =
  (charData : CharacterData, state : String, nameField : String, others : [CharacterData], pid:Process({hear:RequestMsg}));

#parameters
var halfWidth = 560.0;
var halfHeight = 315.0;
var charVelocity = 5.0;

#default room to start with
fun defaultRoom(clientPid) {
  (charData = (id = "None", name = "None", x = halfWidth, y = halfHeight, vx = charVelocity, vy = charVelocity,
  directionV = Still, directionH = Still, imageURL = "None"), state = "enterName", nameField = "", others = [], pid = clientPid)
}

#runs every frame
fun animFrameHandler() {
  animationFrame(fun(_) { NewFrame })
}

var upKey = "ArrowUp";
var downKey = "ArrowDown";
var leftKey = "ArrowLeft";
var rightKey = "ArrowRight";
var spaceKey = " ";

#handler to detect keydown event
fun keyDownHandler() {
  open MvuSubscriptions;

  onKeyDown(fun(evt) {
    var keycode = evt.key;
    if (keycode == upKey) {
      MoveCharV(Up)
    } else if (keycode == downKey) {
      MoveCharV(Down)
    } else if (keycode == leftKey) {
      MoveCharH(Left)
    } else if (keycode == rightKey) {
      MoveCharH(Right)
    } else {
      NoOp
    }
  })
}

#handler to detect keyup event
fun keyUpHandler() {
  open MvuSubscriptions;

  onKeyUp(fun(evt) {
    var keycode = evt.key;
    if (keycode == upKey || keycode == downKey) {
      MoveCharV(Still)
    } else if (keycode == leftKey || keycode == rightKey){
      MoveCharH(Still)
    } else {
      NoOp
    }
  })
}

#as user types into name box, this function is called
fun updateFieldHandler() {
  onInput(fun(str) { UpdateNameField(str) })
}

#when user presses enter, their name is passed into their character data and joins room
fun enterHandler() {
  onEnter(fun() { NameEntered })
}

fun clickHandler() {
  onClick(fun() { Joined })
}

#moves character in certain direction
fun moveChar(charData, direction) {
  if (direction == Up) {
    (charData with y = charData.y -. charVelocity)
  } else if (direction == Down) {
    (charData with y = charData.y +. charVelocity)
  } else if (direction == Left) {
    (charData with x = charData.x -. charVelocity)
  } else if (direction == Right) {
    (charData with x = charData.x +. charVelocity)
  } else {
    charData
  }
}

#removes charData from list of charDatas
fun removeChar(c, cs) {
  switch(cs) {
    case [] -> []
    case x::xs ->
      if (x.id == c.id)
        removeChar(c, xs)
      else
        x :: removeChar(c, xs)
  }
}

#checks if user's character is close to another's character, then displays their cam
sig closeEnough : (CharacterData, CharacterData, Bool) ~> ()
fun closeEnough(c1, c2, isMover) {
  var distance = sqrt((c2.x -. c1.x)^.2.0 +. (c2.y -. c1.y)^.2.0);
  if (distance <= 150.0) {
    if (isMover) {
      WebRTC.connectToUser(c1.id);
      if (WebRTC.checkIfConnectedToPeer(c1.id)) {
        JSApp.addPeerToList(c1.id);
        JSApp.displayLiveStream(c1.id)
      } else {
        ()
      }
    } else {
      if (WebRTC.checkIfConnectedToPeer(c1.id)) {
        JSApp.addPeerToList(c1.id);
        JSApp.displayLiveStream(c1.id)
      } else {
       ()
      }
    }
  } else {
    WebRTC.disconnectFromUser(c1.id);
    JSApp.removePeerVideoDiv(c1.id)
  }
}

#checks whether the user is close to any of their peers
fun closeToOthers(c, others) {
  switch(others) {
    case [] -> ()
    case x::xs ->
      closeEnough(x, c, true);
      closeToOthers(c, xs)
  }
}

#checks to see if a peer's character has been updated by retrieving the new charData
sig retrieveServerMessage : (%) {}~> Msg
fun retrieveServerMessage(pid) {
  spawnWait {
    pid ! RetrieveMsg(self());
    receive {
        case msg -> ServerMsg(msg)
    }
  }
}

#once the user receives an new/updated charData, it updates the room based on it
sig processServerMsg : (CharacterData, Room) ~> Room
fun processServerMsg(charData, room) {
  var c = charData;
  var removeOther = removeChar(c, room.others);
  var addNewOther = c :: removeOther;
  if (c.id <> room.charData.id && room.state == "joined") {
    closeEnough(c, room.charData, false);
    (room with others = addNewOther)
  } else {
    room
  }
}

#main update function in MVU cycle, runs when message (Msg) is received
sig updt : (Msg, Room) ~> (Room, MvuCommands.Command(Msg))
fun updt(msg, room) {
  switch(msg) {
    #every frame, this is the case, updates room based on room
    case NewFrame ->
      var newCharV = moveChar(room.charData, room.charData.directionV);
      var newCharH = moveChar(newCharV, room.charData.directionH);
      ((room with charData = newCharH), MvuCommands.empty)
    #runs when user presses arrow key up or down, updates user's charData
    case MoveCharV(i) ->
      if (room.state == "joined") {
        var updatedChar = (room.charData with directionV = i);
        var newCharV = moveChar(updatedChar, updatedChar.directionV);
        var newCharH = moveChar(newCharV, updatedChar.directionH);
        closeToOthers(newCharH, room.others);
        serverPid ! BcastModelMsg(newCharH);
        ((room with charData = newCharH), MvuCommands.empty)
      } else {
        (room, MvuCommands.empty)
      }
    #runs when user presses arrow key left or right, updates user's charData
    case MoveCharH(i) ->
      if (room.state == "joined") {
        var updatedChar = (room.charData with directionH = i);
        var newCharH = moveChar(updatedChar, updatedChar.directionH);
        var newCharV = moveChar(newCharH, updatedChar.directionV);
        closeToOthers(newCharV, room.others);
        serverPid ! BcastModelMsg(newCharV);
        ((room with charData = newCharV), MvuCommands.empty)
      } else {
        (room, MvuCommands.empty)
      }
    #updates name field of room with the latest keyboard input
    case UpdateNameField(str) ->
      ((room with nameField = str), MvuCommands.empty)
    #updates room state to enter image
    case NameEntered ->
      ((room with state = "enterImage"), MvuCommands.empty)
    #runs when user presses enter, and changes state of room to joined
    case Joined ->
      JSApp.moveLocalVideo();
      var c = (room.charData with id = WebRTC.getUUID(), name = room.nameField, imageURL = "");
      serverPid ! BcastModelMsg(c);
      ((room with charData = c, state = "joined", nameField = ""), MvuCommands.empty)
    case NoOp -> (room, MvuCommands.empty)
    #runs when the client finds a message (charData) in the client loop process
    case ServerMsg(msg) ->
      if (room.state == "joined") {
        serverPid ! BcastModelMsg(room.charData);
        var room = processServerMsg(msg, room);
        var f = fun() { retrieveServerMessage(room.pid) };
        (room, Spawn(f))
      } else {
        var room = processServerMsg(msg, room);
        var f = fun() { retrieveServerMessage(room.pid) };
        (room, Spawn(f))
      }
  }
}

### Rendering
var ae = MvuAttrs.empty;
var he = MvuHTML.empty;
fun ch(xs) { MvuHTML.concat(xs) }
fun ca(xs) { MvuAttrs.concat(xs) }

#HTML for charData
sig drawChar : (CharacterData) -> HTML(Msg)
fun drawChar(c) {
  var x = c.x;
  var y = c.y;
  var name = c.name;
  div (class ("character") +@
       style ("left:" ^^ floatToString(x) ^^ "px;top:" ^^ floatToString(y) ^^ "px;position:absolute;"),
       p (class("charName"), textNode(name))
  )
}

#list of charDatas in HTML
sig listOfHTMLChars : ([CharacterData]) ~> [HTML(Msg)]
fun listOfHTMLChars(cs) {
  switch(cs) {
    case []         -> []
    case charData::xs ->
      var x = floatToString(charData.x);
      var y = floatToString(charData.y);
      drawChar(charData) :: listOfHTMLChars(xs)
  }
}

#HTML UI for welcome page and name box
fun enterNameView(str) {
  div (id ("canvas"),
    div (id ("joinBox"),
      ch([
        h1 (id ("welcomeText"), textNode("Enter your name:")),
        input (
          ca([
            type ("text"),
            name ("enterName"),
            id ("nameBox"),
            value (str),
            updateFieldHandler(),
            enterHandler()
          ]),
          he)
      ])
    )
  )
}

fun enterImageView() {
  JSApp.displayLiveStream("local");
  div (id ("canvas"),
    div (id ("joinBox"),
      ch([
        h1 (id ("welcomeText"), textNode("Take a photo to use as your character icon!")),
        input (
          ca([
            id ("pictureTaker"),
            type ("submit"),
            value ("Use"),
            clickHandler()
          ]),
          he)
      ])
    )
  )
}

fun joinedView(room) {
  var elem = getNodeById("localVideoDiv");
  domSetAttributeFromRef(elem, "style", "position: absolute; left: 1100px; top: 550px;");
  var x = floatToString(room.charData.x);
  var y = floatToString(room.charData.y);
  div (id ("canvas"), ch([
    drawChar(room.charData),
    ch(listOfHTMLChars(room.others))
  ]))
}

#main view function in MVU cycle, display different HTML bases on state of model
sig view : (Room) ~> HTML(Msg)
fun view(room) {
  if (room.state == "joined") {
    joinedView(room)
  } else if (room.state == "enterName") {
    enterNameView(room.nameField)
  } else {
    enterImageView()
  }
}

#subscriptions to detect events for updt function
sig subscriptions : (Room) -> Sub(Msg)
fun subscriptions(model) {
  animFrameHandler() +^ keyUpHandler() +^ keyDownHandler()
}

#sends every message to every process
fun drain(msgs, pids) {
    switch (msgs) {
        case [] -> (msgs, pids)
        case msg :: msgs ->
            switch (pids) {
                case [] -> (msgs, pids)
                case pid :: pids ->
                    pid ! msg;
                    (msgs, pids)
            }
    }
}

#invariant, at least one of msgs, pids is empty.
fun clientLoop(msgs, pids) {
    receive {
      case ModelMessage(msg) ->
        var (msgs, pids) = drain(msgs ++ [msg], pids);
        clientLoop(msgs, pids)
      case RetrieveMsg(pid) ->
        var (msgs, pids) = drain(msgs, pids ++ [pid]);
        clientLoop(msgs, pids)
    }
}

#begins webRTC connection and registers client with server
fun clientRegister() {
  WebRTC.registerUser();
  serverPid ! Register(self());
  clientLoop([], [])
}

fun runMVU(clientPid) {
  WebRTC.waitForWebcam();
  Mvu.run("placeholder", defaultRoom(clientPid), view, updt,
      subscriptions, MvuCommands.spawnProc(fun () { retrieveServerMessage(clientPid) }));
  ()
}

fun mainPage(serverPid) {
  var clientPid = spawnClient { clientRegister() };
  var mvuClient = spawnClient { runMVU(clientPid) };
  page
  <html>
    <head>
      <title>Room</title>
      <link rel="stylesheet" href="css/app.css" type="text/css" />
    </head>
    <body>
      <div id="placeholder"></div>
      <div id="videos"></div>
    </body>
  </html>
}

fun main() {
  addRoute("/", fun(_) { mainPage(serverPid) });
  addStaticRoute("/css", "css", [("css", "text/css")]);
  addStaticRoute("/js", "js", [("js", "text/javascript")]);
  serveWebsockets();
  servePages()
}

main()
